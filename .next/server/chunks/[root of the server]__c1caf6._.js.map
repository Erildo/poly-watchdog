{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///home/orcl/Desktop/pll/lib/polymarket.ts"],"sourcesContent":["import type { PolymarketUser, Position, Trade } from '@/types';\n\nconst POLYMARKET_API = 'https://clob.polymarket.com';\nconst GAMMA_API = 'https://gamma-api.polymarket.com';\n\nexport class PolymarketAPI {\n  // Get user by username\n  static async getUserByUsername(username: string): Promise<PolymarketUser | null> {\n    try {\n      const response = await fetch(`${GAMMA_API}/users?username=${username}`);\n      if (!response.ok) return null;\n      \n      const data = await response.json();\n      return data;\n    } catch (error) {\n      console.error('Error fetching user:', error);\n      return null;\n    }\n  }\n\n  // Get user by address\n  static async getUserByAddress(address: string): Promise<PolymarketUser | null> {\n    try {\n      const response = await fetch(`${GAMMA_API}/users/${address}`);\n      if (!response.ok) return null;\n      \n      const data = await response.json();\n      return data;\n    } catch (error) {\n      console.error('Error fetching user:', error);\n      return null;\n    }\n  }\n\n  // Get user positions\n  static async getPositions(address: string): Promise<Position[]> {\n    try {\n      const response = await fetch(`${GAMMA_API}/positions?user=${address}`);\n      if (!response.ok) return [];\n      \n      const data = await response.json();\n      \n      // Transform API response to our Position type\n      return data.map((position: any) => ({\n        id: position.id,\n        marketId: position.market_id,\n        market: {\n          id: position.market_id,\n          question: position.market?.question || 'Unknown Market',\n          slug: position.market?.slug || '',\n          endDate: position.market?.end_date || '',\n          volume: position.market?.volume || 0,\n          liquidity: position.market?.liquidity || 0,\n        },\n        outcome: position.outcome,\n        size: parseFloat(position.size),\n        averagePrice: parseFloat(position.avg_price),\n        currentPrice: parseFloat(position.current_price || position.avg_price),\n        pnl: parseFloat(position.pnl || '0'),\n        pnlPercentage: parseFloat(position.pnl_percentage || '0'),\n        isOpen: position.is_open,\n        createdAt: position.created_at,\n        closedAt: position.closed_at,\n      }));\n    } catch (error) {\n      console.error('Error fetching positions:', error);\n      return [];\n    }\n  }\n\n  // Get user trade history\n  static async getTrades(address: string, limit = 50): Promise<Trade[]> {\n    try {\n      const response = await fetch(\n        `${GAMMA_API}/trades?user=${address}&limit=${limit}`\n      );\n      if (!response.ok) return [];\n      \n      const data = await response.json();\n      \n      // Transform API response to our Trade type\n      return data.map((trade: any) => ({\n        id: trade.id,\n        marketId: trade.market_id,\n        market: {\n          id: trade.market_id,\n          question: trade.market?.question || 'Unknown Market',\n          slug: trade.market?.slug || '',\n          endDate: trade.market?.end_date || '',\n          volume: trade.market?.volume || 0,\n          liquidity: trade.market?.liquidity || 0,\n        },\n        outcome: trade.outcome,\n        type: trade.side === 'BUY' ? 'BUY' : 'SELL',\n        size: parseFloat(trade.size),\n        price: parseFloat(trade.price),\n        timestamp: trade.timestamp,\n        txHash: trade.tx_hash,\n      }));\n    } catch (error) {\n      console.error('Error fetching trades:', error);\n      return [];\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 149, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 155, "column": 0}, "map": {"version":3,"sources":["file:///home/orcl/Desktop/pll/app/api/user/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { PolymarketAPI } from '@/lib/polymarket';\n\nexport async function GET(request: Request) {\n  const { searchParams } = new URL(request.url);\n  const username = searchParams.get('username');\n  const address = searchParams.get('address');\n\n  if (!username && !address) {\n    return NextResponse.json(\n      { error: 'Username or address required' },\n      { status: 400 }\n    );\n  }\n\n  try {\n    const user = username\n      ? await PolymarketAPI.getUserByUsername(username)\n      : await PolymarketAPI.getUserByAddress(address!);\n\n    if (!user) {\n      return NextResponse.json(\n        { error: 'User not found' },\n        { status: 404 }\n      );\n    }\n\n    return NextResponse.json(user);\n  } catch (error) {\n    return NextResponse.json(\n      { error: 'Failed to fetch user' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEO,eAAe,IAAI,OAAgB;IACxC,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;IAC5C,MAAM,WAAW,aAAa,GAAG,CAAC;IAClC,MAAM,UAAU,aAAa,GAAG,CAAC;IAEjC,IAAI,CAAC,YAAY,CAAC,SAAS;QACzB,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA+B,GACxC;YAAE,QAAQ;QAAI;IAElB;IAEA,IAAI;QACF,MAAM,OAAO,WACT,MAAM,mHAAA,CAAA,gBAAa,CAAC,iBAAiB,CAAC,YACtC,MAAM,mHAAA,CAAA,gBAAa,CAAC,gBAAgB,CAAC;QAEzC,IAAI,CAAC,MAAM;YACT,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAiB,GAC1B;gBAAE,QAAQ;YAAI;QAElB;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAO;QACd,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAuB,GAChC;YAAE,QAAQ;QAAI;IAElB;AACF"}},
    {"offset": {"line": 191, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}